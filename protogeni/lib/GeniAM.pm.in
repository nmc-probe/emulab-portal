#!/usr/bin/perl -wT
#
# Copyright (c) 2008-2013 University of Utah and the Flux Group.
# 
# {{{GENIPUBLIC-LICENSE
# 
# GENI Public License
# 
# Permission is hereby granted, free of charge, to any person obtaining
# a copy of this software and/or hardware specification (the "Work") to
# deal in the Work without restriction, including without limitation the
# rights to use, copy, modify, merge, publish, distribute, sublicense,
# and/or sell copies of the Work, and to permit persons to whom the Work
# is furnished to do so, subject to the following conditions:
# 
# The above copyright notice and this permission notice shall be
# included in all copies or substantial portions of the Work.
# 
# THE WORK IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
# OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
# MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
# NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT
# HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY,
# WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
# OUT OF OR IN CONNECTION WITH THE WORK OR THE USE OR OTHER DEALINGS
# IN THE WORK.
# 
# }}}
#
package GeniAM;

#
# The server side of the CM interface on remote sites. Also communicates
# with the GMC interface at Geni Central as a client.
#
use strict;
use Exporter;
use vars qw(@ISA @EXPORT);

@ISA    = "Exporter";
@EXPORT = qw ( );

use GeniCMV2;
use GeniResponse;
use GeniCredential;
use GeniRegistry;
use emutil;

use Compress::Zlib;
use MIME::Base64;
use XML::LibXML;
use URI;
use Date::Parse;
use Data::Dumper;
use Frontier::RPC2;
use POSIX qw(strftime);
use File::Temp qw(tempfile);

my $TB             = "@prefix@";
my $RSPECLINT      = "$TB/sbin/protogeni/rspeclint";

# Disable UUID checks in GeniCredential.
$GeniCredential::CHECK_UUID = 0;

my $API_VERSION = 2;
my $MAINSITE    = @TBMAINSITE@;

sub SetGeniVersion($)
{
    my ($new_version) = @_;
    if ($new_version eq "1.0") {
	$API_VERSION = 1;
    } elsif ($new_version eq "2.0") {
	$API_VERSION = 2;
    } elsif ($new_version eq "3.0") {
	$API_VERSION = 3;
    } else {
	$API_VERSION = 4;
    }
}

#
# Tell the client what API revision we support.  The correspondence
# between revision numbers and API features is to be specified elsewhere.
# No credentials are required.
#
sub GetVersion()
{
    # $options is optional here for all versions
    my ($options) = @_;
    my $me = GeniAuthority->Lookup($ENV{'MYURN'});
    if (!defined($me)) {
	print STDERR "Could not find local authority object\n";
	return GeniResponse->Create(GENIRESPONSE_ERROR);
    }
    my $commithash = VersionInfo("commithash") || "";
    my $hostname   = `hostname`;
    chomp($hostname);
    my $peers      = {};

    #
    # Ask the Clearinghouse for the peers info.
    #
    if ($MAINSITE) {
	my $clearinghouse = GeniRegistry::ClearingHouse->Create();
	if (!defined($clearinghouse)) {
	    print STDERR "Could not create clearinghouse object.\n";
	    return GeniResponse->Create(GENIRESPONSE_ERROR);
	}
	my $versioninfo;
	if ($clearinghouse->GetVersion(\$versioninfo)) {
	    print STDERR "Could not get peers from clearinghouse.\n";
	    return GeniResponse->Create(GENIRESPONSE_ERROR);
	}
	$peers = $versioninfo->{"peers"};

	foreach my $urn (keys(%{ $peers })) {
	    my $url = $peers->{$urn};
	    $url =~ s/cm$/am/;
	    $peers->{$urn} = $url;
	}
    }

    #
    # We have some confusion here. This is the AM interface, and the
    # URL is different, but the URN and HRN are that of the CM.
    #
    my $url = $me->url();
    $url =~ s/cm$/am/;

    my $coder = Frontier::RPC2->new('use_objects' => 1);

    my $default_ad = {
	"type" => "ProtoGENI",
	"version" => $coder->string("2") };
    my $request_0_1 = {
	"type" => "ProtoGENI",
	"version" => $coder->string("0.1"),
	"schema" => "http://www.protogeni.net/resources/rspec/0.1/request.xsd",
	"namespace" => "http://www.protogeni.net/resources/rspec/0.1",
	"extensions" => []
    };
    my $request_0_2 = {
	"type" => "ProtoGENI",
	"version" => $coder->string("0.2"),
	"schema" => "http://www.protogeni.net/resources/rspec/0.2/request.xsd",
	"namespace" => "http://www.protogeni.net/resources/rspec/0.2",
	"extensions" => []
    };
    my $request_2 = {
	"type" => "ProtoGENI",
	"version" => $coder->string("2"),
	"schema" => "http://www.protogeni.net/resources/rspec/2/request.xsd",
	"namespace" => "http://www.protogeni.net/resources/rspec/2",
	"extensions" => ["http://www.protogeni.net/resources/rspec/ext/emulab/1"]
    };
    my $request_3 = {
	"type" => "GENI",
	"version" => $coder->string("3"),
	"schema" => "http://www.geni.net/resources/rspec/3/request.xsd",
        "namespace" => "http://www.geni.net/resources/rspec/3",
        "extensions" => ["http://www.protogeni.net/resources/rspec/ext/emulab/1"]
    };
    my $ad_0_1 = {
        "type" => "ProtoGENI",
        "version" => $coder->string("0.1"),
        "schema" => "http://www.protogeni.net/resources/rspec/0.1/ad.xsd",
        "namespace" => "http://www.protogeni.net/resources/rspec/0.1",
        "extensions" => []
    };
    my $ad_0_2 = {
        "type" => "ProtoGENI",
        "version" => $coder->string("0.2"),
        "schema" => "http://www.protogeni.net/resources/rspec/0.2/ad.xsd",
        "namespace" => "http://www.protogeni.net/resources/rspec/0.2",
        "extensions" => []
    };
    my $ad_2 = {
        "type" => "ProtoGENI",
        "version" => $coder->string("2"),
        "schema" => "http://www.protogeni.net/resources/rspec/2/ad.xsd",
        "namespace" => "http://www.protogeni.net/resources/rspec/2",
        "extensions" => ["http://www.protogeni.net/resources/rspec/ext/emulab/1"]
    };
    my $ad_3 = {
	"type" => "GENI",
	"version" => $coder->string("3"),
	"schema" => "http://www.geni.net/resources/rspec/3/ad.xsd",
        "namespace" => "http://www.geni.net/resources/rspec/3",
        "extensions" => ["http://www.protogeni.net/resources/rspec/ext/emulab/1"]
    };

    my $request_name = "request_rspec_versions";
    my $ad_name = "ad_rspec_versions";
    if ($API_VERSION > 1) {
	$request_name = "geni_request_rspec_versions";
	$ad_name = "geni_ad_rspec_versions";
    }

    my $blob = {
	"geni_api"   => $API_VERSION,
	"urn"        => $me->urn(),
	"hrn"        => $me->hrn(),
	"url"        => $url,
	"interface"  => "aggregate",
	"code_tag"   => $commithash,
	# XXX
	"hostname"   => $hostname,
	$request_name => [$request_0_1, $request_0_2, $request_2,
			   $request_3],
	$ad_name => [$ad_0_1, $ad_0_2, $ad_2, $ad_3],
	"geni_api_versions" => {
	    "1" => "$url/1.0",
	    "2" => "$url/2.0",
	    "3" => "$url/3.0"
	}
    };
    $blob->{"peers"} = $peers
	if ($MAINSITE);
    $blob->{"default_ad_rspec"} = $default_ad
	if ($API_VERSION == 1);

    if ($API_VERSION >= 3) {
	$blob->{"geni_single_allocation"} = $coder->string("1");
	$blob->{"geni_allocate"} = "geni_disjoint";
	$blob->{"geni_credential_types"} = [
	    {"geni_type" => "geni_sfa",
	     "geni_version" => $coder->string("2")},
	    {"geni_type" => "geni_sfa",
	     "geni_version" => $coder->string("3")}
	    ];
    }
    my $response = GeniResponse->Create(GENIRESPONSE_SUCCESS, $blob);
    if ($API_VERSION > 1) {
	$response->{"geni_api"} = $API_VERSION;
    }
    return $response;
}

# List this aggregates resources. Invokes GeniCMV2::Resolve or
# GeniCMV2::DiscoverResources.
sub ListResources()
{
    my ($credential_args, $options) = @_;
    if (! defined($credential_args) || ! defined($options)
	|| ($API_VERSION > 1 && ! defined($options->{'geni_rspec_version'}))) {
	return GeniResponse->MalformedArgsResponse("Missing arguments");
    }
    my $available = $options->{'geni_available'};
    my $compress = $options->{'geni_compressed'};
    my $slice_urn = $options->{'geni_slice_urn'};
    my $version;
    if ($API_VERSION == 1) {
	$version    = $options->{'rspec_version'} || undef;
    } else {
	$version    = $options->{'geni_rspec_version'};
    }

    my $credentials = $credential_args;
    if ($API_VERSION >= 3) {
	$credentials = FilterCredentials($credential_args);
    }

    my $xml = undef;
    if ($slice_urn) {
	main::AddLogfileMetaData("slice_urn", $slice_urn);

        # If $slice_urn is defined, this turns into a Resolve call.  We
        # need to resolve twice: once to get the sliver urn from the
        # slice, then to get the resources associated with the sliver (a
        # manifest rspec).
        my $resolve_args = {
            'urn' => $slice_urn,
            'credentials' => $credentials
        };
        my $response = GeniCMV2::Resolve($resolve_args);
        if (GeniResponse::IsError($response)) {
            return $response;
        }
        # Get the hash out of the response
        my $slice_hash = GeniResponse::value($response);
        my $sliver = $slice_hash->{'sliver_urn'};
        # Resolve the sliver to get the manifest RSpec
        $resolve_args->{'urn'} = $sliver;
        $response = GeniCMV2::Resolve($resolve_args);
        if (GeniResponse::IsError($response)) {
            return $response;
        }
        $xml = GeniResponse::value($response)->{'manifest'};

    } else {
	my $pgversion = undef;
	if (! defined($version)) {
	    $pgversion = "2";
	} elsif (defined($version->{'type'}) &&
		 defined($version->{'version'}) &&
		 (lc($version->{'type'}) eq "protogeni"
		  || lc($version->{'type'}) eq "geni")) {
	    $pgversion = $version->{'version'};
	} else {
	    return GeniResponse->Create(GENIRESPONSE_ERROR, undef,
					"Only ProtoGENI RSpec advertisements are supported");
	}
        # No slice was specified, so get the advertisement RSpec.
        my $discover_args = {
            'credentials' => $credentials,
            'available' => $available,
	    'rspec_version' => $pgversion,
        };
        my $response = GeniCMV2::DiscoverResources($discover_args);
        if (GeniResponse::IsError($response)) {
            return $response;
        } else {
            $xml = GeniResponse::value($response)
        }

    }

    # Was compression requested?
    if (defined($compress) && ref($compress) eq 'Frontier::RPC2::Boolean') {
	$compress = $compress->value;
    }
    # If compression was requested, do it. The result is a String
    # whose contents are a base64 encoding of a zlib compressed RSpec.
    if ($compress) {
        my $coder = Frontier::RPC2->new();
        $xml = encode_base64( compress( $xml ) );
    }
    # Finally, return the RSpec
    return GeniResponse->Create(GENIRESPONSE_SUCCESS, $xml);
}

sub auto_add_sa($)
{
    my ($cred_str) = @_;
    my $verify_sig = 1;
    my $cred = GeniCredential->CreateFromSigned($cred_str, $verify_sig);
    my $signers = $cred->signer_certs();

    # The credential has been verified, so the signer derives from a
    # trusted root.
    my $sa_cert = @$signers[0];

    # These are borrowed from protogeni/scripts/addauthority
    my $certificate = GeniCertificate->LoadFromString($sa_cert);
    if (!defined($certificate)) {
        print STDERR "auto_add_sa: could not get certificate from $sa_cert\n";
        return;
    }
    if (! ($certificate->uuid() =~ /\w*-(\w*)$/)) {
        print STDERR "auto_add_sa: could not get prefix from uuid\n";
        return;
    }
    my $url = $certificate->URL();
    if (!defined($url)) {
        print STDERR "auto_add_sa: certificate does not have a URL extension\n";
    }
    my $urn = $certificate->urn();
    if (!defined($urn)) {
        print STDERR "auto_add_sa: certificate does not have a URN extension\n";
        return;
    }
    # Look to see if already registered.
    my $authority = GeniAuthority->Lookup($urn);
    if (defined($authority)) {
	#
	# See if the certificate has changed. If so we want to replace it.
	#
	return
	    if ($certificate->SameCert($authority->GetCertificate()));

	#
	# Want to reuse the old uuid since we use it as a table cross
	# reference index. Eventually need to use the URN. Anyway, change
	# the uuid in the new certificate so that it goes into the DB
	# with the original one. Then update the Authority record with
	# the new certificate.
	#
	print STDERR "Updating $authority with new certificate: $certificate\n";
	
	$certificate->setuuid($authority->uuid());
	if ($authority->UpdateCertificate($certificate)) {
	    print STDERR "Failed to update $authority with $certificate\n";
	    return;
	}
	return;
    }
    #
    # We want the URL! 
    #
    goto goturl
	if (defined($url));
    
    # First get the list of registries from PLC.
    my $registry = GeniRegistry::PLC->Create();
    if (!defined($registry)) {
	print STDERR "Cannot create a PLC registry object\n";
	return;
    }
    my $blob;
    if ($registry->GetRegistries(\$blob)) {
	print STDERR "Cannot get PLC registry listing\n";
	return;
    }
    print STDERR Dumper($blob);

    #
    # Now look at the last signer certificate; this is the actual authority.
    #
    my $authcertstr = @$signers[scalar(@$signers) - 1];
    my $authcert = GeniCertificate->LoadFromString($authcertstr);
    if (!defined($authcert)) {
        print STDERR
	    "auto_add_sa: could not get certificate from $authcertstr\n";
        return;
    }
    my $authurn = $authcert->urn();
    if (!defined($authurn)) {
        print STDERR "auto_add_sa: $authcert does not have a URN extension\n";
        return;
    }

    #
    # Now search ...
    #
    foreach my $ref (@$blob) {
	if ($ref->{'urn'} eq $authurn) {
	    $url = $ref->{'url'};
	    last;
	}
    }
    if (!defined($url)) {
        print STDERR "auto_add_sa: could not get a URL for $authcert\n";
	return;
    }
    #
    # Gack. Replace the URL with a modified URL which says https.
    # Why does PLC set the scheme to http?
    #
  goturl:
    my $uri = URI->new($url);
    $uri->scheme("https");
    $url = "$uri";
    
    if (!GeniAuthority->Create($certificate, $url, "sa")) {
        print STDERR "auto_add_sa: unable to add authority\n";
        return;
    }
    return $certificate;
}

###############################################################################
# AM API V2
###############################################################################

# Create a sliver by allocating and starting resources.
sub CreateSliver()
{
    my ($slice_urn, $credentials, $rspec, $users, $options) = @_;
    if (! defined($slice_urn) || ! defined($credentials)
	|| ! defined($rspec) || ! defined($users)
	|| (! defined($options) && $API_VERSION > 1)) {
	return GeniResponse->MalformedArgsResponse("Missing arguments");
    }

    foreach my $cred (@$credentials) {
        # If we want to remove the SA(s) after this call, push them
        # onto a list here and remove them at the end of this
        # function. The other AM calls do not need the dynamically
        # added SA.
        auto_add_sa($cred);
    }

    # Package the caller_keys in a list of hashes the way the CM wants
    # it. Each hash has two keys ('type' and 'key'). 'type' is always
    # 'ssh' for us, and 'key' is the key.
    my $sliver_keys = undef;
    if (@$users) {
	$sliver_keys = [];
	foreach my $user (@$users) {
	    my $user_urn  = $user->{'urn'};
	    my @user_keys = ();

	    foreach my $key (@{ $user->{keys} }) {
		# The CMV2 does not like newlines at the end of the keys.
		chomp($key);
		push(@user_keys, {'type' => 'ssh', 'key' => $key});
	    }
	    push(@{$sliver_keys}, {'urn'  => $user_urn,
				   'keys' => \@user_keys});
	}
    }
    # Invoke CreateSliver
    my $create_args = {
        'slice_urn' => $slice_urn,
        'rspec' => $rspec,
        'credentials' => $credentials,
        'keys' => $sliver_keys
    };
    my $response = GeniCMV2::CreateSliver($create_args);
    if (!ref($response)) {
	# This is cause GeniCMV2::CreateSliver does a fork, and the child
	# returns plain status code, which should go to our caller. 
	return $response;
    }
    if (GeniResponse::IsError($response)) {
        # The create failed, so return the response.
        return $response
    }

    # The create succeeded so gather the response info
    my $listref = GeniResponse::value($response);
    my ($sliver_credential, $manifest_rspec) = @{$listref};
    return GeniResponse->Create( GENIRESPONSE_SUCCESS, $manifest_rspec );
}

# Just delegate to CMV2::DeleteSlice. If we ever change to sliver_urns
# for this call, we'll probably want to call CMV2::DeleteSliver
# instead.
sub DeleteSliver()
{
    my ($slice_urn, $credentials, $options) = @_;
    if (! defined($slice_urn) || ! defined($credentials)
	|| (! defined($options) && $API_VERSION > 1)) {
	return GeniResponse->MalformedArgsResponse("Missing arguments");
    }

    my $delete_args = {
        'slice_urn' => $slice_urn,
        'credentials' => $credentials
    };
    my $response = GeniCMV2::DeleteSlice($delete_args);
    if (GeniResponse::IsError($response)) {
        return $response;
    } else {
        # Return an XML-RPC boolean
        my $coder = Frontier::RPC2->new();
        return GeniResponse->Create(GENIRESPONSE_SUCCESS, $coder->boolean(1));
    }
}

# No prototype because it is recursive and as such, the prototype
# causes a warning.
#
# Return a hash containing a JSONish representation of the given node.
sub XmlToJson
{
    my ($node) = @_;
 
    my $attrs = {};
    foreach my $attr ($node->attributes) {
        $attrs->{$attr->nodeName()} = $attr->nodeValue();
    }

    my $children = [];
    foreach my $child ($node->childNodes) {
        if ($child->nodeType() == XML_ELEMENT_NODE) {
            push(@$children, XmlToJson($child));
        }
    }

    my $result = {
        "name" => $node->nodeName(),
        "attributes" => $attrs,
        "children" => $children
    };
    return $result;
}

# Get the status of the sliver associated with the given slice. This
# just passes on to the CM SliverStatus operation.
sub SliverStatus()
{
    my ($slice_urn, $credentials, $options) = @_;
    if (! defined($slice_urn) || ! defined($credentials)
	|| (! defined($options) && $API_VERSION > 1)) {
	return GeniResponse->MalformedArgsResponse("Missing arguments");
    }

    my $status_args = {
        'slice_urn' => $slice_urn,
        'credentials' => $credentials,
    };
    my $response = GeniCMV2::SliverStatus($status_args);
    if (GeniResponse::IsError($response)) {
        return $response
    }
    # $status is a hash ref
    my $pgstatus = GeniResponse::value($response);
    my $status = {};

    $status->{'geni_urn'} = $slice_urn;

    # Determine geni_status. XXX how to determine 'configuring'?
    if ($pgstatus->{'status'} eq 'ready') {
        $status->{'geni_status'} = 'ready';
    } elsif ($pgstatus->{'status'} eq 'failed') {
        $status->{'geni_status'} = 'failed';
    } else {
        $status->{'geni_status'} = 'unknown';
    }

    # include the pg status
    $status->{'pg_status'} = $pgstatus->{'status'};
    $status->{'pg_public_url'} = $pgstatus->{'public_url'}
        if (exists($pgstatus->{'public_url'}));

    # include the expiration, converting to UTC
    my $slice = GeniSlice->Lookup($slice_urn);
    my @expires = gmtime(str2time($slice->expires()));
    my $expires_str = POSIX::strftime("%Y-%m-%dT%H:%M:%S", @expires);
    $status->{'pg_expires'} = $expires_str;

    # Grab the keys (logins) for inclusion.
    my $slice_experiment = $slice->GetExperiment();
    if (!defined($slice_experiment)) {
	print STDERR "*** No Experiment for $slice\n";
    }
    else {
	my $bindings;
	if ($slice_experiment->NonLocalUsers(\$bindings)) {
	    print STDERR "*** No bindings for $slice_experiment\n";
	}
	elsif (@{ $bindings }) {
	    $status->{'users'} = $bindings;
	}
    }

    my $details = $pgstatus->{'details'};
    my @children = ();
    while ( my ($pgurn, $pgrstat) = each(%$details) ) {
        my $child = {
            'geni_urn' => $pgurn,
            # XXX Need to massage status to one of the AM status values
            'geni_status' => $pgrstat->{'status'},
            'geni_error' => $pgrstat->{'error'},
            'pg_status' => $pgrstat->{'status'},
        };
        # Look up the sliver so we can extract info from the manifest.
        my $sliver = GeniSliver->Lookup($pgurn);
	if (!defined($sliver)) {
	    $sliver = GeniAggregate->Lookup($pgurn);
	}
	# Signal an error?
	next
	    if (!defined($sliver));

        # Put manifest info in...
        my $manifest = $sliver->GetManifest(0);
        if (0) {
            # An example of how to include a single element from the
            # manifest. Abondoned this approach and went to XmlToJson
            # instead. Finds the "login", then the "hostname" inside
            # the rspec
            my $login = GeniXML::FindNodes(".//n:services//n:login", $manifest);
            if (defined($login)) {
                my $login = @$login[0];
                my $host = GeniXML::GetText("hostname", $login);
                if (defined($host)) {
                    $child->{'pg_hostname'} = $host;
                }
            }
        }
        $child->{'pg_manifest'} = XmlToJson($manifest);
        #$child->{'pg_xml_manifest'} = GeniXML::Serialize($manifest);
        push @children, $child;
    }
    $status->{'geni_resources'} = \@children;

    return GeniResponse->Create(GENIRESPONSE_SUCCESS, $status);
}

sub RenewSliver()
{
    my ($slice_urn, $credentials, $expiration_time, $options) = @_;
    if (! defined($slice_urn) || ! defined($credentials)
	|| ! defined($expiration_time)
	|| (! defined($options) && $API_VERSION > 1)) {
	return GeniResponse->MalformedArgsResponse("Missing arguments");
    }

    my $renew_args = {
        'slice_urn' => $slice_urn,
        'expiration' => $expiration_time,
        'credentials' => $credentials
    };
    my $response = GeniCMV2::RenewSlice($renew_args);
    if (GeniResponse::IsError($response)) {
        return $response;
    }

    # Return an XML-RPC boolean
    my $coder = Frontier::RPC2->new();
    return GeniResponse->Create(GENIRESPONSE_SUCCESS, $coder->boolean(1));
}

sub Shutdown()
{
    my ($slice_urn, $credentials, $options) = @_;
    if (! defined($slice_urn) || ! defined($credentials)
	|| (! defined($options) && $API_VERSION > 1)) {
	return GeniResponse->MalformedArgsResponse("Missing arguments");
    }

    my $shutdown_args = {
        'slice_urn' => $slice_urn,
        'credentials' => $credentials
    };
    my $response = GeniCMV2::Shutdown($shutdown_args);
    if (GeniResponse::IsError($response)) {
        return $response;
    }

    # Return an XML-RPC boolean
    my $coder = Frontier::RPC2->new();
    return GeniResponse->Create(GENIRESPONSE_SUCCESS, $coder->boolean(1));
}

sub CreateImage()
{
    my ($slice_urn, $imagename, $sliver_urn, $credential_args, $options) = @_;
    if (! defined($slice_urn) || ! defined($credential_args) ||
	! defined($sliver_urn) || ! defined($imagename)
	|| (! defined($options) && $API_VERSION > 1)) {
	return GeniResponse->MalformedArgsResponse("Missing arguments");
    }

    my $credentials = $credential_args;
    if ($API_VERSION >= 3) {
	$credentials = FilterCredentials($credential_args);
    }

    my $args = {
        'slice_urn' => $slice_urn,
        'sliver_urn' => $sliver_urn,
        'imagename' => $imagename,
        'credentials' => $credentials
    };
    $args->{'global'} = $options->{'global'}
        if (defined($options) && exists($options->{'global'}));
	
    my $response = GeniCMV2::CreateImage($args);
    return $response;
}

sub DeleteImage()
{
    my ($image_urn, $credentials, $options) = @_;
    if (! defined($image_urn) || ! defined($credentials) ||
	(! defined($options) && $API_VERSION > 1)) {
	return GeniResponse->MalformedArgsResponse("Missing arguments");
    }

    my $args = {
        'image_urn' => $image_urn,
        'credentials' => $credentials
    };
    $args->{'creator_urn'} = $options->{'creator_urn'}
        if (defined($options) && exists($options->{'creator_urn'}));
    
    my $response = GeniCMV2::DeleteImage($args);
    if (GeniResponse::IsError($response)) {
        return $response;
    }

    # Return an XML-RPC boolean
    my $coder = Frontier::RPC2->new();
    return GeniResponse->Create(GENIRESPONSE_SUCCESS, $coder->boolean(1));
}

sub ListImages()
{
    my ($user_urn, $credentials, $options) = @_;
    if (! defined($user_urn) || ! defined($credentials) ||
	(! defined($options) && $API_VERSION > 1)) {
	return GeniResponse->MalformedArgsResponse("Missing arguments");
    }

    my $args = {
        'user_urn' => $user_urn,
        'credentials' => $credentials
    };
    my $response = GeniCMV2::ListImages($args);
    return $response;
}

###############################################################################
# AM API V3
###############################################################################

sub Describe
{
    my ($urn_args, $credential_args, $options) = @_;
    if (! defined($urn_args) || ! defined($credential_args)
	|| ! defined($options)) {
	return GeniResponse->MalformedArgsResponse("Missing arguments");
    }
    my @urns = @{ $urn_args };
    my $credentials = FilterCredentials($credential_args);

    my $cred = GeniCMV2::CheckCredentials($credentials);
    return $cred
	if (GeniResponse::IsResponse($cred));

    my ($slice, $aggregate) = GeniCMV2::Credential2SliceAggregate($cred);
    return GeniResponse->Create(GENIRESPONSE_REFUSED, undef,
				"Slice credential not provided")
	if (! defined($slice));
    return $slice
	if (GeniResponse::IsResponse($slice));
    my $ticket = GeniTicket->SliceTicket($slice);
    return GeniResponse->Create(GENIRESPONSE_REFUSED, undef,
				"No slivers here")
	if (! defined($ticket) && ! defined($aggregate));

    if (scalar(@urns) != 1 || $urns[0] ne $slice->urn()) {
	return GeniResponse->Create(GENIRESPONSE_REFUSED, undef,
				    "Must pass only slice URN");
    }

    my $manifest;
    if (defined($aggregate)) {
	$aggregate->ComputeState();
	$manifest = $aggregate->GetManifest()
    }
    $manifest = $ticket->rspec()
	if (defined($ticket));
    my @geni_slivers = ();
    my $sliver_blob;

    # Add any slivers that are provisioned (exist in the aggregate)
    if (defined($aggregate)) {
	my $expires = GeniXML::GetText("expires", $manifest);
	if (! defined($expires)) {
	    return GeniResponse->Create(GENIRESPONSE_ERROR, undef,
					"Manifest is missing expires tag");
	}
	my @slivers = ();
	if ($aggregate->SliverList(\@slivers) != 0) {
	    return GeniResponse->Create(GENIRESPONSE_ERROR, undef,
					"Could not get slivers list");
	}
	foreach my $sliver (@slivers) {
	    $sliver_blob = {
		'geni_sliver_urn' => $sliver->sliver_urn(),
		'geni_expires' => $aggregate->expires(),
		'geni_allocation_status' => "geni_provisioned",
		'geni_operational_status' => GetOpState($sliver),
		'geni_error' => ''
	    };
	    push(@geni_slivers, $sliver_blob);
	}
    }
    # Add any slivers which are allocated (exist in the ticket)
    if (defined($ticket)) {
	# Get expiration date from ticket
	my $parser = XML::LibXML->new;
	my $doc;
	eval {
	    $doc = $parser->parse_string($ticket->asString());
	};
	if ($@) {
	    return GeniResponse->Create(GENIRESPONSE_ERROR, undef,
					"Failed to parse ticket string: $@");
	}
	my ($expires_node) = $doc->getElementsByTagName("expires");
	if (!defined($expires_node)) {
	    return GeniResponse->Create(GENIRESPONSE_ERROR, undef,
					"Ticket is missing expires node");
	}
	my $expires = $expires_node->to_literal();

	# Get list of slivers from the rspec
	my $rspec = $ticket->rspec();
	my $sliverids = RspecToSlivers(GeniXML::Serialize($rspec));
	foreach my $sliverid (@{ $sliverids }) {
	    $sliver_blob = {
		'geni_sliver_urn' => $sliverid,
		'geni_expires' => $expires,
		'geni_allocation_status' => "geni_allocated",
		'geni_operational_status' => "geni_pending_allocation",
		'geni_error' => ''
	    };
	    push(@geni_slivers, $sliver_blob);
	}
    }

    my $blob = {
	'geni_rspec' => GeniXML::Serialize($manifest),
	'geni_urn' => $slice->urn(),
	'geni_slivers' => \@geni_slivers
    };
    return GeniResponse->Create(GENIRESPONSE_SUCCESS, $blob);
}

sub Allocate
{
    my ($slice_urn, $credential_args, $rspec, $options) = @_;
    Update($slice_urn, [], $credential_args, $rspec, $options);
}

sub Update
{
    my ($slice_urn, $urn_args, $credential_args, $rspec, $options) = @_;
    if (! defined($slice_urn) || ! defined($urn_args) ||
	! defined($credential_args) || ! defined($rspec) ||
	! defined($options)) {
	return GeniResponse->MalformedArgsResponse("Missing arguments");
    }
    my @urns = @{ $urn_args };
    my $credentials = FilterCredentials($credential_args);
    my $cred = GeniCMV2::CheckCredentials($credentials);
    return $cred
	if (GeniResponse::IsResponse($cred));

    my ($slice, $aggregate) = GeniCMV2::Credential2SliceAggregate($cred);
    if (defined($slice)) {
	main::AddLogfileMetaDataFromSlice($slice);

	# If a monitor process is running, we are "busy".
	if ($slice->monitor_pid()) {
	    return GeniResponse->MonitorResponse();
	}
    }

    # The URN list must be either empty or contain the slice URN.
    if (scalar(@urns) > 1 ||
	(scalar(@urns) == 1 && $urns[0] ne $slice->urn())) {
	return GeniResponse->Create(GENIRESPONSE_REFUSED, undef,
				    "Must pass only slice URN");
    }

    # If the URN list is empty, then we just create new slivers,
    # combining the new rspec with the old.
    my $isCreate = 0;
    if (scalar(@urns) == 0) {
	$isCreate = 1;
    }

    my $response = CheckRspec("REQUEST", $rspec);
    return $response
	if (defined($response));

    my $ticket;
    if (defined($slice)) {
	return $slice
	    if (GeniResponse::IsResponse($slice));
	$ticket = GeniTicket->SliceTicket($slice);
    }

    my $combined = $rspec;
    if (defined($ticket)) {
	if ($isCreate) {
	    $combined = CombineDisjoint(GeniXML::Serialize($ticket->rspec()),
					$rspec);
	    $response = CheckRspec("COMBINED W/ TICKET", $combined);
	    return $response
		if (defined($response));
	}
	$response = AllocateTicket($slice_urn, $combined, $credentials,
				   $ticket->asString());
    } elsif (defined($aggregate)) {
	if ($isCreate) {
	    $combined = CombineDisjoint( $aggregate->GetManifest(), $rspec);
	    $response = CheckRspec("COMBINED W/ AGGREGATE", $combined);
	    return $response
		if (defined($response));
	}
	$response = AllocateAggregate($slice_urn, $combined, $credentials,
				      $aggregate->urn());
    } else {
	$response = AllocateEmpty($slice_urn, $rspec, $credentials);
    }

    if (! GeniResponse::IsError($response)) {
	my $description = Describe([$slice_urn], $credential_args, []);
	if (! GeniResponse::IsError($description)) {
	    my $rspec = $description->{'value'}->{'geni_rspec'};
	    my $blob = {
		'geni_rspec' => $rspec,
		'geni_slivers' => []
	    };
	    for my $sliver (@{ $description->{'value'}->{'geni_slivers'} }) {
		my $out = {
		    'geni_sliver_urn' => $sliver->{'geni_sliver_urn'},
		    'geni_expires' => $sliver->{'geni_expires'},
		    'geni_allocation_status' =>
			$sliver->{'geni_allocation_status'}
		};
		push (@{ $blob->{'geni_slivers'} }, $out);
	    }
	    $response = GeniResponse->Create(GENIRESPONSE_SUCCESS, $blob);
	} else {
	    $response = $description;
	}
    }
    return $response;
}

# Allocate when there is a ticket or ticket+sliver
sub AllocateTicket
{
    my ($slice_urn, $combined, $credentials, $ticketStr) = @_;
    if (GeniResponse::IsResponse($combined)) {
	return $combined;
    }

    my $args = {
	'slice_urn' => $slice_urn,
	'ticket' => $ticketStr,
	'rspec' => $combined,
	'credentials' => $credentials
    };
    return GeniCMV2::UpdateTicket($args);
}

# Allocate when there is a sliver but no ticket
sub AllocateAggregate
{
    my ($slice_urn, $combined, $credentials, $sliver_urn) = @_;
    if (GeniResponse::IsResponse($combined)) {
	return $combined;
    }
    my $args = {
	'sliver_urn' => $sliver_urn,
	'rspec' => $combined,
	'credentials' => $credentials
    };
    return GeniCMV2::UpdateSliver($args);
}

# Allocate when there are no slices or slivers
sub AllocateEmpty
{
    my ($slice_urn, $rspec, $credentials) = @_;
    my $args = {
	'slice_urn' => $slice_urn,
	'rspec' => $rspec,
	'credentials' => $credentials
    };

    return GeniCMV2::GetTicket($args);
}

sub Renew
{
    my ($urn_args, $credential_args, $expiration_time, $options) = @_;
    if (! defined($urn_args) || ! defined($credential_args) ||
	! defined($expiration_time) || ! defined($options)) {
	return GeniResponse->MalformedArgsResponse("Missing arguments");
    }
    my $credentials = FilterCredentials($credential_args);
    my @urns = @{ $urn_args};
    return GeniResponse->MalformedArgsResposne("Empty URN List")
	if (scalar(@urns) < 1);
    my $args = {
	'slice_urn' => $urns[0],
	'expiration' => $expiration_time,
	'credentials' => $credentials
    };
    my $response = GeniCMV2::RenewSlice($args);
    if (! GeniResponse::IsError($response)) {
	my $description = Describe($urn_args, $credential_args, []);
	if (! GeniResponse::IsError($description)) {
	    $response = GeniResponse->Create(GENIRESPONSE_SUCCESS,
				      $description->{'value'}->{'geni_slivers'});
	} else {
	    $response = $description;
	}
    }
    return $response;
}

sub Provision
{
    my ($urn_args, $credential_args, $options) = @_;
    if (! defined($urn_args) || ! defined($credential_args) ||
	! defined($options)) {
	return GeniResponse->MalformedArgsResponse("Missing arguments");
    }
    my @urns = @{ $urn_args };
    return GeniResponse->MalformedArgsResposne("Empty URN List")
	if (scalar(@urns) < 1);
    my $credentials = FilterCredentials($credential_args);
    my $users = $options->{'geni_users'};
    my $sliver_keys = [];
    if (defined($users) && @$users) {
	foreach my $user (@$users) {
	    my $user_urn  = $user->{'urn'};
	    my @user_keys = ();

	    foreach my $key (@{ $user->{keys} }) {
		# The CMV2 does not like newlines at the end of the keys.
		chomp($key);
		push(@user_keys, {'type' => 'ssh', 'key' => $key});
	    }
	    push(@{$sliver_keys}, {'urn'  => $user_urn,
				   'keys' => \@user_keys});
	}
    }

    my $cred = GeniCMV2::CheckCredentials($credentials);
    return $cred
	if (GeniResponse::IsResponse($cred));

    my ($slice, undef) = GeniCMV2::Credential2SliceAggregate($cred);
    return GeniResponse->Create(GENIRESPONSE_REFUSED, undef,
				"Slice credential not provided")
	if (! defined($slice));

    return $slice
	if (GeniResponse::IsResponse($slice));

    if (scalar(@urns) != 1 || $urns[0] ne $slice->urn()) {
	return GeniResponse->Create(GENIRESPONSE_REFUSED, undef,
				    "Must pass only slice URN");
    }

    my $ticket = GeniTicket->SliceTicket($slice);
    return GeniResponse->Create(GENIRESPONSE_REFUSED, undef,
				"No allocated slivers exist")
	if (! defined($ticket));

    my $args = {
	'slice_urn' => $urns[0],
	'ticket' => $ticket->ticket_string(),
	'credentials' => $credentials,
	'keys' => $sliver_keys
    };

    my $response = GeniCMV2::RedeemTicket($args);
    if (! GeniResponse::IsError($response)) {
	my $description = Describe($urn_args, $credential_args, []);
	if (! GeniResponse::IsError($description)) {
	    my $blob = {
		'geni_rspec' => $description->{'value'}->{'geni_rspec'},
		'geni_slivers' => $description->{'value'}->{'geni_slivers'}
	    };
	    $response = GeniResponse->Create(GENIRESPONSE_SUCCESS, $blob);
	} else {
	    $response = $description;
	}
    }
    return $response;
}

sub Status
{
    my $response = Describe(@_);
    if (! GeniResponse::IsError($response)) {
	my $blob = {
	    'geni_urn' => $response->{'value'}->{'geni_urn'},
	    'geni_slivers' => $response->{'value'}->{'geni_slivers'}
	};
	$response = GeniResponse->Create(GENIRESPONSE_SUCCESS, $blob);
    }
    return $response;
}

sub PerformOperationalAction
{
    my ($urn_args, $credential_args, $action, $options) = @_;
    my @urns = @{ $urn_args };
    return GeniResponse->MalformedArgsResposne("Empty URN List")
	if (scalar(@urns) < 1);

    my $credentials = FilterCredentials($credential_args);
    my $args = {
	'credentials' => $credentials
    };

    my $cred = GeniCMV2::CheckCredentials($credentials);
    return $cred
	if (GeniResponse::IsResponse($cred));

    my ($slice, undef) = GeniCMV2::Credential2SliceAggregate($cred);
    return GeniResponse->Create(GENIRESPONSE_REFUSED, undef,
				"Slice credential not provided")
	if (! defined($slice));

    if ($urns[0] eq $slice->urn()) {
	$args->{'slice_urn'} = $slice->urn();
    } else {
	$args->{'sliver_urns'} = $urn_args;
    }

    if ($action eq 'geni_start') {
	return GeniCMV2::StartSliver($args);
    } elsif ($action eq 'geni_restart') {
	return GeniCMV2::RestartSliver($args);
    } elsif ($action eq 'geni_stop') {
	return GeniCMV2::StopSliver($args);
    } else {
	return GeniResponse->Create(GENIRESPONSE_REFUSED, undef,
				    "Invalid operational action");
    }

}

sub Delete
{
    my ($urn_args, $credential_args, $option_args) = @_;
    my @urns = @{ $urn_args };
    return GeniResponse->MalformedArgsResposne("Empty URN List")
	if (scalar(@urns) < 1);

    # Must create return structure before deletion because this data
    # won't exist afterwards.
    my $description = Describe($urn_args, $credential_args, []);
    return $description
	if (GeniResponse::IsError($description));
    my $slivers = [];
    foreach my $sliver (@{ $description->{'value'}->{'geni_slivers'} }) {
	my $blob = {
	    'geni_sliver_urn' => $sliver->{'geni_sliver_urn'},
	    'geni_allocation_status' => 'geni_unallocated',
	    'geni_expires' => $sliver->{'geni_expires'},
	    'geni_error' => ''
	};
	push(@{ $slivers }, $blob);
    }

    my $credentials = FilterCredentials($credential_args);
    my $args = {
	'slice_urn' => $urns[0],
	'credentials' => $credentials
    };
    my $response = GeniCMV2::DeleteSlice($args);
    if (! GeniResponse::IsError($response)) {
	$response = GeniResponse->Create(GENIRESPONSE_SUCCESS, $slivers);
    }
    return $response;
}

sub Cancel
{
    my ($urn_args, $credential_args, $option_args) = @_;
    my @urns = @{ $urn_args };
    return GeniResponse->MalformedArgsResposne("Empty URN List")
	if (scalar(@urns) < 1);

    my $credentials = FilterCredentials($credential_args);
    my $cred = GeniCMV2::CheckCredentials($credentials);
    return $cred
	if (GeniResponse::IsResponse($cred));

    my ($slice, undef) = GeniCMV2::Credential2SliceAggregate($cred);
    my $response;
    my $ticket = GeniTicket->SliceTicket($slice);
    if (defined($ticket)) {
	my $credentials = FilterCredentials($credential_args);
	my $args = {
	    'slice_urn' => $urns[0],
	    'ticket' => $ticket->ticket_string(),
	    'credentials' => $credentials
	};
	$response = GeniCMV2::ReleaseTicket($args);
    }
    if (! GeniResponse::IsError($response)) {
	$response = Describe($urn_args, $credential_args, []);
    }
    return $response;
}

# Filter out any credentials of an uknown type leaving only geni_sfa
# version 2 and version 3 credentials in a list. Also invokes
# auto_add_sa on each credential.
sub FilterCredentials
{
    my ($credentials) = @_;
    my $result = [];
    foreach my $cred (@{ $credentials }) {
	if ($cred->{'geni_type'} eq "geni_sfa" &&
	    ($cred->{'geni_version'} eq 2 || $cred->{'geni_version'} eq 3)) {
	    push(@{ $result }, $cred->{'geni_value'});
	    auto_add_sa($cred->{'geni_value'});
	}
    }
    return $result;
}

# Determines operational state based on the state/status of a sliver.
sub GetOpState
{
    my ($sliver) = @_;
    my $result = 'geni_ready';
    if ($sliver->status() eq 'failed') {
	$result = 'geni_failed';
    } elsif ($sliver->status() eq 'unknown') {
	$result = 'unknown';
    } elsif ($sliver->status() eq 'ready') {
	$result = 'geni_ready';
    } elsif ($sliver->status() eq 'changing'
	     && $sliver->state() eq 'started') {
	$result = 'geni_configuring';
    } elsif ($sliver->status() eq 'notready') {
	$result = 'geni_notready';
    } elsif ($sliver->status() eq 'changing'
	     && $sliver->state() eq 'stopped') {
	$result = 'geni_stopping';
    } elsif ($sliver->status() eq 'created'
	     && $sliver->state() eq 'new') {
	$result = 'geni_notready';
    }
    print STDERR $sliver->status() . ", " . $sliver->state() . ", " . $result . "\n";
    return $result;
}

# Rspec is expected to be in string form.
# Returns a list of sliver URNs found in the rspec.
sub RspecToSlivers
{
    my $result = [];
    my ($rspecStr) = @_;
    my $rspec = GeniXML::Parse($rspecStr);
    if (defined($rspec)) {
	foreach my $noderef (GeniXML::FindNodes("n:node",
						$rspec)->get_nodelist()) {
	    my $sliver_id = GeniXML::GetSliverId($noderef);
	    if (defined($sliver_id)) {
		push(@{ $result }, $sliver_id);
	    }
	}
    }
    return $result;
}

# Rspec is an XML tree.
# Returns a table of client_ids
sub RspecToClientIds
{
    my $result = {};
    my ($rspec) = @_;
    if (defined($rspec)) {
	my @nodes = GeniXML::FindNodes("n:node",
				       $rspec)->get_nodelist();
	my @links = GeniXML::FindNodes("n:link",
				       $rspec)->get_nodelist();
	my @ifaces = GeniXML::FindNodes("n:node/n:interface",
					$rspec)->get_nodelist();
	push(@nodes, @links, @ifaces);
	foreach my $noderef (@nodes) {
	    my $id = GeniXML::GetVirtualId($noderef);
	    if (defined($id)) {
		$result->{$id} = 1;
	    }
	}
    }
    return $result;    
}

# currentStr and newStr are both rspec strings
# Returns a combined rspec string or a GeniResponse error
sub CombineDisjoint
{
    my ($currentStr, $newStr) = @_;
    my $current = GeniXML::Parse($currentStr);
    my $new = GeniXML::Parse($newStr);
    if (! defined($current) || ! defined($new)) {
	return GeniResponse->Create(GENIRESPONSE_ERROR, undef,
				    "Could not parse rspecs on allocate");
    }
    my $currentIds = RspecToClientIds($current);
    my $newIds = RspecToClientIds($new);
    my $found = 0;
    foreach my $id (keys(%{ $newIds })) {
	if (exists($currentIds->{$id})) {
	    $found = 1;
	    last;
	}
    }
    if ($found) {
	return GeniResponse->Create(GENIRESPONSE_ERROR, undef,
				    "New rspec is not disjoint from sliver");
    }

    foreach my $child ($new->childNodes()) {
	$current->appendChild($child);
    }

    return GeniXML::Serialize($current);
}

# Returns true if the list of slivers has a slice urn
sub HasSliceUrn
{
    my ($slice, $slivers) = @_;
    my $result = 0;
    foreach my $item (@{ $slivers }) {
	if ($slice->urn() eq $item) {
	    $result = 1;
	    last;
	}
    }
    return $result;
}

# Returns true if left and right are the same set of slivers.
sub SameSlivers
{
    my ($left, $right) = @_;
    my $result = 1;
    my %leftTable = ();
    foreach my $item (@{ $left }) {
	$leftTable{$item} = 1;
    }
    if (scalar(keys(%leftTable)) != scalar(@{ $right })) {
	$result = 0;
    } else {
	foreach my $item (@{ $right }) {
	    if (! exists($leftTable{$item})) {
		$result = 0;
		last;
	    }
	}
    }
    return $result;
}

# Check rspec using rspeclint
# Returns undefined on success or a GeniResponse on error.
sub CheckRspec
{
    my ($type, $rspec) = @_;
    my $result;

    my ($fh, $filename) = tempfile(UNLINK => 0);
    if (!defined($fh)) {
	$result = GeniResponse->Create(GENIRESPONSE_ERROR, undef,
				       "Could not check rspec");
    } else {
	print $fh $rspec;
	close($fh);
	my $rspecerrors = `$RSPECLINT $filename 2>&1`;
	if ($?) {
	    unlink($filename);
	    $result = GeniResponse->Create(GENIRESPONSE_ERROR,
					   $rspecerrors,
					   $type . " rspec does not validate");
	}
	if ($rspecerrors ne "") {
	    print STDERR "--- BEGIN RSPECLINT ERRORS $type ---\n";
	    print STDERR $rspecerrors;
	    print STDERR "--- END RSPECLINT ERRORS $type ---\n\n";
	}
	unlink($filename);
    }
    return $result;
}

# _Always_ make sure that this 1 is at the end of the file...
1;
