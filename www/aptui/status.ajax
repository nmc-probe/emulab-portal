<?php
#
# Copyright (c) 2000-2015 University of Utah and the Flux Group.
# 
# {{{EMULAB-LICENSE
# 
# This file is part of the Emulab network testbed software.
# 
# This file is free software: you can redistribute it and/or modify it
# under the terms of the GNU Affero General Public License as published by
# the Free Software Foundation, either version 3 of the License, or (at
# your option) any later version.
# 
# This file is distributed in the hope that it will be useful, but WITHOUT
# ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
# FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Affero General Public
# License for more details.
# 
# You should have received a copy of the GNU Affero General Public License
# along with this file.  If not, see <http://www.gnu.org/licenses/>.
# 
# }}}
#
chdir("..");
include_once("webtask.php");
include_once("geni_defs.php");
chdir("apt");
include_once("profile_defs.php");
include_once("instance_defs.php");

# Set these globals below.
$instance = null;
$creator  = null;

#
# Locate the objects and check permission.
#
function StatusSetupAjax($needmodify)
{
    global $this_user, $ajax_args;
    global $instance, $creator;

    if (!isset($ajax_args["uuid"])) {
	SPITAJAX_ERROR(1, "Missing instance uuid");
	return 1;
    }
    $uuid = $ajax_args["uuid"];
    $instance = Instance::Lookup($uuid);
    if (!$instance) {
	SPITAJAX_ERROR(1, "no such instance uuid: $uuid");
	return 1;
    }
    $creator = GeniUser::Lookup("sa", $instance->creator_uuid());
    if (! $creator) {
	$creator = User::LookupByUUID($instance->creator_uuid());
    }
    if (!$creator) {
	SPITAJAX_ERROR(1, "no such instance creator");
	return 1;
    }
    # Admin users do whatever they like.
    if (isset($this_user) && ISADMIN()) {
	return 0;
    }
    # For a guest user; must be the same guest that created experiment.
    if (get_class($creator) == "GeniUser") {
        if (isset($_COOKIE['quickvm_user']) &&
            $_COOKIE['quickvm_user'] == $creator->uuid()) {
            return 0;
        }
	SPITAJAX_ERROR(1, "You do not have permission!");
	return 1;
    }
    # An experiment created by a real user, can be accessed by other
    # members of the project, subject to modify restrictions.
    if (! (isset($this_user) && get_class($creator) == "User" &&
           $instance->CanView($this_user) &&
           (!$needmodify || $instance->CanModify($this_user)))) {
	SPITAJAX_ERROR(1, "You do not have permission!");
	return 1;
    }
    return 0;
}

#
# Status/
#
function Do_GetInstanceStatus()
{
    global $instance, $creator, $APTBASE;

    if (StatusSetupAjax(0)) {
	return;
    }
    $blob = array();
    $blob["status"] = $instance->status();
    $blob["sliverstatus"] = array();
    $blob["sliverurls"]   = array();

    if ($instance->logfileid()) {
        $blob["logfile_url"] =
            "$APTBASE/spewlogfile.php?logfile=" . $instance->logfileid();
    }
    
    #
    # If we have all of our manifests, the client can request them
    # and show the topology.
    #
    $havemanifests = 1;

    foreach ($instance->slivers() as $sliver) {
        if (!$sliver->manifest()) {
            $havemanifests = 0;
        }
        else {
            if ($sliver->webtask_id() &&
                $webtask = WebTask::Lookup($sliver->webtask_id())) {
                $sliverstatus = $webtask->TaskValue("sliverstatus");
                if ($sliverstatus) {
                    $blob["sliverstatus"][$sliver->aggregate_urn()] =
                        $sliverstatus;
                }
            }
        }
        if ($sliver->public_url()) {
            $blob["sliverurls"][] = array("name" => $sliver->aggregate_name(),
                                          "url"  => $sliver->public_url());
        }
    }
    $blob["havemanifests"] = $havemanifests;

    # Reflect errors back to the user.
    $webtask = WebTask::LookupByObject($instance->uuid());
    if ($webtask && $webtask->exited()) {
        if ($webtask->exitcode() == 26) {
            $blob["reason"]  = "Not enough free nodes, please try again later.";
            $blob["reason"] .= "\n\n";
        }
        elseif ($webtask->exitcode() == 25) {
            $blob["reason"]  = "Not enough available bandwidth for a link.\n\n";
        }
        elseif ($webtask->exitcode() == 28) {
            $blob["reason"]  = "Your topology could not be mapped to physical ".
                "resources.\n\n";
        }
        elseif ($webtask->exitcode() == 8) {
            $blob["reason"]  = "Your experiment timed out while setting up, ".
                "most likely because one or more nodes failed to boot. The ".
                "node consoles may provide more information.\n\n";
        }
        elseif ($webtask->exitcode() == 1) {
            #
            # This is GENIRESPONSE_BADARGS which typically means an error
            # in the input rspec, something the user must have put in it.
            #
            $blob["reason"]  = "Your topology source contains invalid ".
                "values.\n\n";
        }
        else {
            $blob["reason"] = "";
        }
        $blob["reason"] .= htmlentities($webtask->TaskValue("output"));
    }
    SPITAJAX_RESPONSE($blob);
}

#
# Terminate.
#
function Do_TerminateInstance()
{
    global $instance, $creator, $this_user, $ajax_args;

    if (StatusSetupAjax(1)) {
	return;
    }
    $uuid = $instance->uuid();
    $webtask_id = WebTask::GenerateID();

    if ($instance->admin_lockdown() || $instance->user_lockdown()) {
        if (! (isset($this_user) &&
               ($instance->creator() == $this_user->uid() || ISADMIN()))) {
            SPITAJAX_ERROR(1, "Not enough permission to terminate; ".
                           "experiment is locked down");
            return;
        }
        $override = substr($uuid, 2, 5);

        if (! (isset($ajax_args["lockdown_override"]) &&
               $ajax_args["lockdown_override"] == $override)) {
            SPITAJAX_ERROR(1, "Lockdown override is incorrect");
            return;
        }
        $retval = SUEXEC($this_user->uid(), "nobody",
                         "webmanage_instance -t $webtask_id -- ".
                         "  lockdown $uuid clear all",
                         SUEXEC_ACTION_CONTINUE);
        if ($retval) {
            $webtask = WebTask::Lookup($webtask_id);

            if ($webtask && $webtask->exited()) {
                SPITAJAX_ERROR(1, $webtask->TaskValue("output"));
                $webtask->Delete();
            }
            else {
                SPITAJAX_ERROR(-1, "Internal Error. Please try again later");
            }
            return;
        }
    }
    # We do not want to see the busy errors, and that is the only error
    # that gets returned, that is not also emailed by the script. So just
    # use the ignore option.
    $retval = SUEXEC("nobody", "nobody",
                     "webmanage_instance terminate $uuid",
                     SUEXEC_ACTION_IGNORE);

    if ($retval == 0) {
	SPITAJAX_RESPONSE("");
	return;
    }
    SPITAJAX_ERROR(-1, "Your experiment is probably busy, ".
        "please try again later.");
}

#
# Manifest.
#
function Do_GetInstanceManifest()
{
    global $instance, $creator;

    if (StatusSetupAjax(0)) {
	return;
    }

    $blob = array();

    foreach ($instance->slivers() as $sliver) {
        if ($sliver->manifest()) {
            $blob[$sliver->aggregate_urn()] = $sliver->manifest();
        }
    }
    SPITAJAX_RESPONSE($blob);
}

#
# SSH Auth Object
#
function Do_GetSSHAuthObject()
{
    global $instance, $creator, $this_user;
    global $ajax_args;

    if (!isset($ajax_args["hostport"])) {
	SPITAJAX_ERROR(1, "Missing hostport");
	return 1;
    }
    $hostport = $ajax_args["hostport"];
    
    if (StatusSetupAjax(1)) {
	return;
    }
    #
    # XXX Need to deal with multiple members of an experiment.
    #
    if (! ((isset($this_user) && $this_user->SameUser($creator)) ||
	   (isset($_COOKIE['quickvm_user']) &&
	    $_COOKIE['quickvm_user'] == $creator->uuid()))) {
	SPITAJAX_ERROR(1, "Not allowed to ssh; only the creator");
	return;
    }
    
    $nodeid = $ajax_args["nodeid"];
    $auth   = SSHAuthObject($creator->uid(), $hostport);
    if (!$auth) {
	SPITAJAX_ERROR(1, "Could not create authentication object");
	return;
    }
    SPITAJAX_RESPONSE($auth);
}

#
# Request automatic extension.
#
function Do_RequestExtension()
{
    global $instance, $creator, $this_user, $suexec_output;
    global $ajax_args;
    global $TBMAIL_OPS, $APTMAIL, $EXTENSIONS, $APTBASE;
    $autoextend_maximum = TBGetSiteVar("aptui/autoextend_maximum");
    $autoextend_maxage  = TBGetSiteVar("aptui/autoextend_maxage");
    $reason  = "";
    $message = "";
    $needapproval = 0;
    $granted = 0;

    if (StatusSetupAjax(1)) {
	goto bad;
    }
    $uuid = $instance->uuid();
    $slice = GeniSlice::Lookup("sa", $instance->slice_uuid());
    if (!slice) {
	SPITAJAX_ERROR(1, "no slice for instance");
	goto bad;
    }
    $expires_time = strtotime($slice->expires());
    $created_time = strtotime($instance->created());

    if ($autoextend_maximum == 0 && !ISADMIN()) {
	SPITAJAX_ERROR(1, "Extensions are currenly disabled; please ".
                       "contact us if you need to make special arrangements.");
	goto bad;
    }

    if (!isset($ajax_args["howlong"]) || $ajax_args["howlong"] == "") {
	SPITAJAX_ERROR(1, "Missing number of days");
	goto bad;
    }
    $granted = $wanted = $ajax_args["howlong"];
    if (! preg_match("/^\d+$/", $wanted)) {
	SPITAJAX_ERROR(1, "Invalid characters in days");
	goto bad;
    }

    if (ISADMIN()) {
	if ($wanted < 1 || $wanted > 365) {
	    SPITAJAX_ERROR(1, "Must be an integer 1 <= days <= 365");
	    goto bad;
	}
        $reason = "Your experiment was extended by the site administrator.\n";
	if (isset($ajax_args["reason"]) && $ajax_args["reason"] != "") {
            $reason .= "\n" . $ajax_args["reason"];
        }
    }
    else {
	if (!isset($ajax_args["reason"]) || $ajax_args["reason"] == "") {
	    SPITAJAX_ERROR(1, "Missing reason");
	    goto bad;
	}
	$reason  = $ajax_args["reason"];

        if (!TBvalid_fulltext($reason)) {
	    SPITAJAX_ERROR(1, "Illegal characters in reason");
	    goto bad;
        }

	#
	# Guest users are treated differently.
	#
	if (!isset($this_user)) {
            # Only extend for 24 hours. More later.
            $granted = 1;

	    if ($expires_time > time() + (3600 * 24 * $granted)) {
		SPITAJAX_ERROR(1, "You still have a day left. ".
			       "Try again tomorrow");
		goto delay;
	    }
	}
	else {
            $diff  = $expires_time - time();
            $cdiff = time() - $created_time;

            #
            # If admin lockout, we are refusing any more free time.
            #
            if ($instance->extension_lockout()) {
                $needapproval = 1;
                $granted = 0;
                $message = "because you are not allowed any more ".
                    "free extensions";
            }
            #
            # After maxage, all extension requests require admin approval.
            #
            elseif ($cdiff > (3600 * 24 * $autoextend_maxage)) {
                #
                # Well, unless they asked for less then the free grant,
                # which is a nice loophole people will probably notice.
                #
                $granted = 2;
                
                if ($wanted > $granted) {
                    $needapproval = 1;
                    $message = "because it was started more then ".
                        "$autoextend_maxage days ago";
                }
            }
            #
            # Temporary for GEC23
            #
            elseif (0 && (time() + ($wanted * 3600 * 24) >
                          strtotime("2015-06-15 12:00:00"))) {
                $granted = 1;
                $needapproval = 1;
                $message = "because the testbed is mostly reserved for GEC23";
            }
	    #
	    # Registered users are granted up to the autoextend_maximum
            # automatically. Beyond that, requires approval, but we still
            # give them whatever the free extension is, since we want
            # to give them extra time until the next meeting of the
            # "resource management committee."
	    #
	    elseif ($wanted > $autoextend_maxage) {
                #
                # We have plenty of time left, no extension just a message.
                #
                if ($diff > (3600 * 24 * 7)) {
                    needAdminApproval($wanted, 0, $reason,
                                      "because it was for longer then ".
                                      "$autoextend_maximum days");
                    goto delay;
                }
                $needapproval = 1;
                $granted = $autoextend_maximum;
                $message = "because it was for longer then ".
                    "$autoextend_maximum days";
	    }
            else {
                if ($diff > (3600 * 24 * 7)) {
                    SPITAJAX_ERROR(1, "You still have a week left!");
                    goto bad;
                }
            }
	    #
	    # The most we allow is the autoextend_maximum out, no
	    # matter what they asked for. So, if the autoextend_maximum
	    # is a week and there are five days left and they asked
	    # for seven, we give them two.
	    #
            if ($expires_time + ($granted * 3600 * 24) >
                time() + (3600 * 24 * $autoextend_maximum)) {
		$seconds = (3600 * 24 * $autoextend_maximum) - $diff;
                $granted = intval($seconds / (3600 * 24));
	    }
        }
    }
    if ($granted > 0) {
        $seconds = 3600 * 24 * $granted;
        $retval = SUEXEC("nobody", "nobody",
                         "webmanage_instance extend $uuid $seconds",
                         SUEXEC_ACTION_CONTINUE);
    }

    if ($retval == 0) {
	# Refresh. 
	$slice = GeniSlice::Lookup("sa", $instance->slice_uuid());
	$new_expires = date("Y-m-d H:i:s T", strtotime($slice->expires()));
        $created = date("Y-m-d H:i:s T", strtotime($instance->created()));
        $before = date("Y-m-d H:i:s T", $expires_time);
        $now = date("Y-m-d H:i:s T", time());
        list($cluster) = Instance::ParseURN($instance->aggregate_urn());

        #
        # We store each extension request in an ongoing text field.
        #
        $text =
            "Date: $now\n".
            "Wanted: $wanted, Granted: $granted\n".
            "Before: $before\n".
            "After $new_expires\n".
            "Reason:\n".
            $reason . "\n\n".
            "-----------------------------------------------\n";
        $instance->AddExtensionHistory($text);

        if ($needapproval) {
            needAdminApproval($wanted, $granted, $reason, $message);
            if (!$granted)
                goto delay;
            return;
        }
	SPITAJAX_RESPONSE($new_expires);

	$instance->SendEmail($creator->email(),
	       "Experiment Extension: $uuid",
               (ISADMIN() ? $reason :
                "A request to extend your experiment was made and ".
                "granted.\n".
                "Your reason was:\n\n". $reason) .
               "\n\n".
               "Your experiment was started on $created\n".
 	       "Your experiment will now expire at $new_expires\n".
               "It is running on $cluster\n\n\n".
               "$APTBASE/status.php?uuid=$uuid\n",
	       "From: $EXTENSIONS\n" .
	       "BCC: $EXTENSIONS");
        #
        # We do not want to overwrite the reason in the DB if this
        # was an admin extension, we want to keep whatever the user
        # has written previously.
        #
        if (! ISADMIN()) {
            $instance->SetExtensionReason($reason);
        }
        else {
            $instance->SetExtensionRequested(0);
        }
        $instance->BumpExtensionCount($granted);
    }
    elseif ($retval > 0) {
	SPITAJAX_ERROR(1, $suexec_output);
	goto bad;
    }
    else {
	SPITAJAX_ERROR(-1, "Internal Error. Please try again later");
	goto bad;
    }
    return;
bad:
delay:
    sleep(1);
}

#
# Deny extension,
#
function Do_DenyExtension()
{
    global $instance, $creator, $this_user, $suexec_output;
    global $ajax_args;
    global $TBMAIL_OPS, $APTMAIL, $EXTENSIONS, $APTBASE;
    $reason  = "";
    $message = "";

    if (StatusSetupAjax(1)) {
	goto bad;
    }
    $uuid = $instance->uuid();
    $slice = GeniSlice::Lookup("sa", $instance->slice_uuid());
    if (!slice) {
	SPITAJAX_ERROR(1, "no slice for instance");
	goto bad;
    }
    if (!ISADMIN()) {
	SPITAJAX_ERROR(1, "You do not have permission to do this.");
	goto bad;
    }
    $reason = "Your extension was denied by the site administrator!\n";
    if (isset($ajax_args["message"]) && $ajax_args["message"] != "") {
        $reason .= "\n" . $ajax_args["message"];
    }

    $expires = date("Y-m-d H:i:s T", strtotime($slice->expires()));
    $created = date("Y-m-d H:i:s T", strtotime($instance->created()));
    $now     = date("Y-m-d H:i:s T", time());

    #
    # We store each extension request in an ongoing text field.
    #
    $text =
        "Date: $now\n".
        "Expires: $expires\n".
        "Reason:\n".
        $reason . "\n\n".
        "-----------------------------------------------\n";
    $instance->AddExtensionHistory($text);

    $instance->SendEmail($creator->email(),
	       "Experiment Extension Denied: $uuid",
               $reason .
               "\n\n".
               "Your experiment was started on $created\n".
 	       "Your experiment expires at $expires\n".
               "$APTBASE/status.php?uuid=$uuid\n",
	       "From: $EXTENSIONS\n" .
	       "BCC: $EXTENSIONS");

    $instance->SetExtensionRequested(0);
    SPITAJAX_RESPONSE("Success");
bad:
delay:
    sleep(1);
}

#
# Helper for above.
#
function needAdminApproval($wanted, $granted, $reason, $message)
{
    global $instance, $creator, $this_user, $suexec_output;
    global $EXTENSIONS, $APTBASE;

    $uuid = $instance->uuid();
    # Subtract out the extra time we added above.
    $howlong = $wanted - $granted;
    $url = "$APTBASE/status.php?uuid=$uuid&extend=$howlong";

    # Refresh. 
    $slice = GeniSlice::Lookup("sa", $instance->slice_uuid());
    $new_expires = date("Y-m-d H:i:s T",
                        strtotime($slice->expires()) + ($howlong * 3600 * 24));
    $created = date("Y-m-d H:i:s T", strtotime($instance->created()));
    list($cluster) = Instance::ParseURN($instance->aggregate_urn());
		    
    $instance->SendEmail($EXTENSIONS,
        "Experiment Extension Request: $uuid",
        "A request to extend this experiment was made but requires\n".
        "administrator approval" .
        ($message ? " $message" : "") . ".\n\n" .
        "The request was for $wanted days, we granted $granted days, ".
        "the reason given is:\n\n".
        $reason . "\n\n".
        "This experiment was started on $created\n".
        "Granting the request would set the expiration to $new_expires\n".
        "It is running on $cluster\n".
        "\n\n". $url . "\n\n",
        "From: " . $creator->email());

    $instance->SetExtensionReason($reason);
    $instance->BumpExtensionCount($granted);
    $instance->SetExtensionRequested(1);
            
    # XXX 
    SPITAJAX_ERROR(2, "Your request requires admininstrator approval".
                   ($message ? " because $message" : "") . ". " .
                   "You will receive email if/when your ".
                   "request is granted (or denied). Thanks!");
    return;
}

#
# Request a console URL and pass back to the status page.
#
function Do_ConsoleURL()
{
    global $instance, $creator, $this_user, $suexec_output;
    global $ajax_args;

    if (StatusSetupAjax(0)) {
	return;
    }
    if (!isset($this_user)) {
	SPITAJAX_ERROR(1, "Only registered users can view node consoles");
	return;
    }
    if (!isset($ajax_args["node"])) {
	SPITAJAX_ERROR(1, "Missing node argument");
	return 1;
    }
    $node = $ajax_args["node"];
    $uuid = $instance->uuid();
    $slice = GeniSlice::Lookup("sa", $instance->slice_uuid());
    if (!slice) {
	SPITAJAX_ERROR(1, "no slice for instance");
	return 1;
    }
    $webtask_id = WebTask::GenerateID();
    $retval = SUEXEC("nobody", "nobody",
		     "webmanage_instance -t $webtask_id -- consoleurl $uuid " .
		     escapeshellarg($node),
		     SUEXEC_ACTION_IGNORE);
    $webtask = WebTask::Lookup($webtask_id);

    if ($retval == 0) {
        $taskdata = $webtask->TaskData();
        $blob = array();
        $blob["url"] = $taskdata["url"];
        if (isset($taskdata["password"])) {
            $blob["password"] = $taskdata["password"];
        }
        if (isset($taskdata["logurl"])) {
            $blob["logurl"] = $taskdata["logurl"];
        }
	SPITAJAX_RESPONSE($blob);
	$webtask->Delete();
	return;
    }
    elseif ($retval < 0) {
        SUEXECERROR(SUEXEC_ACTION_CONTINUE);
    }
    if ($webtask) {
	SPITAJAX_ERROR(1, $webtask->TaskValue("output"));
	$webtask->Delete();
    }
    elseif ($suexec_output != "") {
        SPITAJAX_ERROR(1, $suexec_output);
    }
    else {
	SPITAJAX_ERROR(-1, "Internal Error. Please try again later");
    }
}

#
# Fire off a snapshot.
#
function Do_Snapshot()
{
    global $this_user, $instance, $suexec_output;
    global $ajax_args;

    if (StatusSetupAjax(1)) {
	return;
    }
    if (!isset($this_user)) {
	SPITAJAX_ERROR(1, "Only registered users can snapshot nodes");
	return;
    }
    $this_idx = $this_user->uid_idx();
    $uuid = $ajax_args["uuid"];
    
    if ($this_idx != $instance->creator_idx() && !ISADMIN()) {
	SPITAJAX_ERROR(1, "Not enough permission. Maybe Clone instead?");
	return;
    }
    if ($instance->status() != "ready") {
	SPITAJAX_ERROR(1, "Experiment is currently busy");
	return;
    }
    #
    # The profile also has to belong to the user, since it is
    # going to be modified to use the new image.
    #
    $profile = Profile::Lookup($instance->profile_id(),
			       $instance->profile_version());
    if (!$profile) {
	SPITAJAX_ERROR(1, "Cannot lookup profile for instance");
	return;
    }
    if ($this_idx != $profile->creator_idx() && !ISADMIN()) {
	SPITAJAX_ERROR(1, "Not your profile to change. Clone first!");
	return;
    }
    $optargs = "";
    if (isset($ajax_args["node_id"]) && $ajax_args["node_id"] != "") {
        $node_id = $ajax_args["node_id"];
        if (!TBvalid_vnode_id($node_id)) {
            SPITAJAX_ERROR(1, "Bad node id");
            return;
        }
        $optargs .= " -n $node_id ";

        if (isset($ajax_args["update_profile"]) &&
            $ajax_args["update_profile"]) {
            $optargs .= " -u all ";
        }
    }
    else {
        #
        # Single node profile snapshot, we always update the profile.
        #
        $optargs .= " -u node ";
    }
    if (isset($ajax_args["update_prepare"]) &&
        $ajax_args["update_prepare"]) {
        $optargs .= " -U ";
    }
    
    #
    # Call out to the backend.
    #
    $webtask_id = WebTask::GenerateID();
    $retval = SUEXEC($this_user->uid(), "nobody",
		     "webmanage_instance -t $webtask_id -- ".
                     "  snapshot $uuid $optargs",
		     SUEXEC_ACTION_IGNORE);
    $webtask = WebTask::Lookup($webtask_id);

    if ($retval != 0) {
	if ($retval < 0) {
	    SPITAJAX_ERROR(-11, "Internal error, cannot proceed.");
	    # Notify tbops.
	    SUEXECERROR(SUEXEC_ACTION_CONTINUE);
	}
	elseif ($webtask) {
	    SPITAJAX_ERROR(1, $webtask->TaskValue("output"));
	}
	elseif ($suexec_output != "") {
	    SPITAJAX_ERROR(1, $suexec_output);
        }
	else {
	    SPITAJAX_ERROR(-1, "Internal Error. Please try again later");
	}
	if ($webtask) {
	    $webtask->Delete();
	}
	return;
    }
    if ($webtask && $webtask->exited()) {
	$webtask->Delete();
    }
    SPITAJAX_RESPONSE("Success");
}

#
# Return snapshot status.
#
function Do_SnapshotStatus()
{
    global $this_user, $instance;
    global $ajax_args;

    if (StatusSetupAjax(1)) {
	return;
    }
    if (!isset($this_user)) {
	SPITAJAX_ERROR(1, "Only registered users can snapshot nodes");
	return;
    }
    $this_idx = $this_user->uid_idx();

    if ($this_idx != $instance->creator_idx() && !ISADMIN()) {
	SPITAJAX_ERROR(1, "Not enough permission");
	return;
    }
    $webtask = WebTask::LookupByObject($instance->uuid());
    if (!$webtask) {
	SPITAJAX_ERROR(1, "No status descriptor found");
	return;
    }
    $taskdata = $webtask->TaskData();
    $blob = array();

    #
    # Size is in KB to avoid bigint problems. But kill the KB.
    # 
    if (isset($taskdata["image_size"])) {
	if (preg_match("/^(\d+)KB$/", $taskdata["image_size"], $matches)) {
	    $taskdata["image_size"] = $matches[1]; 
	}
	$blob["image_size"] = $taskdata["image_size"];
    }
    else {
	$blob["image_size"] = 0;
    }
    $blob["node_status"]  = $taskdata["rawstate"];
    $blob["image_status"] = $taskdata["image_status"];
    if ($webtask->exited()) {
	# Success, but not sure what to report. Come back to this later.
	$blob["exited"]   = $webtask->exited();
	$blob["exitcode"] = $webtask->exitcode();
        if (isset($taskdata["image_name"])) {
            $blob["image_name"] = $taskdata["image_name"];
        }
	$webtask->Delete();
    }
    SPITAJAX_RESPONSE($blob);
}

#
# Ask the backend to refresh sliverstatus
#
function Do_Refresh()
{
    global $this_user, $instance, $suexec_output;
    global $ajax_args;

    #
    # Guest users can do this.
    #
    if (StatusSetupAjax(1)) {
	return;
    }
    $this_idx = $this_user->uid_idx();
    $uuid = $ajax_args["uuid"];
    if ($this_idx != $instance->creator_idx() && !ISADMIN()) {
	SPITAJAX_ERROR(1, "Not enough permission. Maybe Clone instead?");
	return;
    }
    #
    # Call out to the backend.
    #
    $webtask_id = WebTask::GenerateID();
    $retval = SUEXEC("nobody", "nobody",
		     "webmanage_instance -t $webtask_id -- refresh $uuid",
		     SUEXEC_ACTION_IGNORE);
    $webtask = WebTask::Lookup($webtask_id);

    if ($retval != 0) {
	if ($retval < 0) {
	    SPITAJAX_ERROR(-11, "Internal error, cannot proceed.");
	    # Notify tbops.
	    SUEXECERROR(SUEXEC_ACTION_CONTINUE);
	}
	elseif ($webtask) {
	    SPITAJAX_ERROR(1, $webtask->TaskValue("output"));
	}
	elseif ($suexec_output != "") {
	    SPITAJAX_ERROR(1, $suexec_output);
        }
	else {
	    SPITAJAX_ERROR(-1, "Internal Error. Please try again later");
	}
	if ($webtask) {
	    $webtask->Delete();
	}
	return;
    }
    SPITAJAX_RESPONSE("Success");
}

#
# Ask the backend to reboot or reload a node.
#
function Do_RebootOrReload($which)
{
    global $this_user, $instance, $suexec_output;
    global $ajax_args;

    if (StatusSetupAjax(1)) {
	return;
    }
    if (!isset($this_user)) {
	SPITAJAX_ERROR(1, "Only registered users can reboot/reload nodes");
	return;
    }
    $this_idx = $this_user->uid_idx();
    $uuid = $ajax_args["uuid"];

    if (!isset($ajax_args["node_id"])) {
	SPITAJAX_ERROR(1, "Missing node_id");
	return;
    }
    $node_id = $ajax_args["node_id"];
    if (!preg_match("/^[-\w]+$/", $node_id)) {
        SPITAJAX_ERROR(1, "Illegal characters in node_id");
    }
    if ($this_idx != $instance->creator_idx() && !ISADMIN()) {
	SPITAJAX_ERROR(1, "Not enough permission. Maybe Clone instead?");
	return;
    }
    if ($instance->status() != "ready" && $instance->status() != "failed") {
	SPITAJAX_ERROR(1, "Experiment is currently busy");
	return;
    }

    #
    # Call out to the backend.
    #
    $webtask_id = WebTask::GenerateID();
    $retval = SUEXEC($this_user->uid(), "nobody",
		     "webmanage_instance -t $webtask_id -- ".
                     "  $which $uuid " . escapeshellarg($node_id), 
		     SUEXEC_ACTION_IGNORE);
    $webtask = WebTask::Lookup($webtask_id);

    if ($retval != 0) {
	if ($retval < 0) {
	    SPITAJAX_ERROR(-11, "Internal error, cannot proceed.");
	    # Notify tbops.
	    SUEXECERROR(SUEXEC_ACTION_CONTINUE);
	}
	elseif ($webtask) {
	    SPITAJAX_ERROR(1, $webtask->TaskValue("output"));
	}
	elseif ($suexec_output != "") {
	    SPITAJAX_ERROR(1, $suexec_output);
        }
        else {
	    SUEXECERROR(SUEXEC_ACTION_CONTINUE);
	    SPITAJAX_ERROR(-1, "Internal Error. Please try again later");
	}
	if ($webtask) {
	    $webtask->Delete();
	}
	return;
    }
    if ($webtask) {
	$webtask->Delete();
    }
    SPITAJAX_RESPONSE("Success");
}
function Do_Reboot()
{
    Do_RebootOrReload("reboot");
}
function Do_Reload()
{
    Do_RebootOrReload("reload");
}

#
# Set or clear the lockout flag
#
function Do_Lockout()
{
    global $this_user;
    global $ajax_args;

    if (!isset($this_user) || !ISADMIN()) {
	SPITAJAX_ERROR(1, "Not enough permission.");
	return;
    }
    $this_idx = $this_user->uid_idx();

    if (!isset($ajax_args["uuid"])) {
	SPITAJAX_ERROR(1, "Missing profile uuid");
	return;
    }
    if (!isset($ajax_args["lockout"])) {
	SPITAJAX_ERROR(1, "Missing lockout value");
	return;
    }
    $uuid = $ajax_args["uuid"];
    $instance = Instance::Lookup($uuid);
    if (!$instance) {
	SPITAJAX_ERROR(1, "Unknown instance uuid");
	return;
    }
    $lockout = ($ajax_args["lockout"] ? 1 : 0);
    if (!DBQueryWarn("update apt_instances set extension_adminonly='$lockout' ".
                     "where uuid='$uuid'")) {
	SPITAJAX_ERROR(1, "Database failure.");
	return;
    }
    SPITAJAX_RESPONSE("Success");
}

# Local Variables:
# mode:php
# End:
?>
