#!/usr/bin/perl -w
#
# EMULAB-COPYRIGHT
# Copyright (c) 2005-2012 University of Utah and the Flux Group.
# All rights reserved.
#
use English;
use Getopt::Std;
use Date::Parse;
use Time::Local;

#
# Drill down the node history data in the DB
#

# un-taint path
$ENV{'PATH'} = '/bin:/usr/bin:/usr/local/bin:/usr/site/bin';
delete @ENV{'IFS', 'CDPATH', 'ENV', 'BASH_ENV'};

#
# Turn off line buffering on output
#
$| = 1; 

# Load the Testbed support stuff.
use lib "@prefix@/lib";
use libdb;

use POSIX qw(ctime);

#
# Magic: Wed Jan 12 13:59:00 2005
# When Leigh implemented the history log.
#
my $epoch = 1105563540;

sub usage {
    print("Usage: $0 [-ARalrsvw] [node ...]\n".
    "  -A       print history of all nodes (you do NOT want to do this)\n".
    "  -R       print raw records (default is to combine some records)\n".
    "  -S field sort list by field (date, node, pideid, uid, elapsed)\n".
    "  -a       show only when allocated to experiment\n".
    "  -l       list records\n".
    "  -n num   report on only the first num records (after sorting)\n".
    "             use negative value for last num records\n".
    "  -r       reverse order (most recent first)\n".
    "  -s       show a summary of node's past usage\n".
    "  -d date  Start at YYYY-MM-DD HH:MM:SS\n".
    "  -c       used with -d, show current status of all nodes\n".
    "  -v       verbose output\n".
    "  -w       print warnings about anomolous records\n");
    exit(1);
}

my $optlist = "ARS:aln:rswvd:i:ct:x:";
my $warnme = 0;
my $verbose = 0;
my $showall = 0;
my $showcurrent = 0;
my $showalloconly = 0;
my $list = 0;
my $summary = 0;
my $raw = 0;
my $numrecs = 0;
my $datetime;
my $datelimit;
my $startrecord;
my $ip;

#
# Sort stuff.  sortby value should correspond to record field format:
#
my %sortmap = (
    "node"    => 0,
    "pideid"  => 6,
    "uid"     => 3,
    "date"    => 1,
    "elapsed" => 2
);
my $sortbydate = $sortmap{date};
my $sortby = $sortbydate;
my $revorder = 0;

# Sort function: first by indicated field, secondarily by date
sub byfield()
{
    # already sorted by date
    return 0 if ($sortby == $sortbydate);

    # int compare for elapsed
    if ($sortby == $sortmap{elapsed}) {
	return @$a[$sortby] <=> @$b[$sortby] ||
	    @$a[$sortbydate] <=> @$b[$sortbydate];
    }

    # string compare for everything else
    return @$a[$sortby] cmp @$b[$sortby] ||
	@$a[$sortbydate] <=> @$b[$sortbydate];
}


#
# Parse command arguments.
#
%options = ();
if (! getopts($optlist, \%options)) {
    usage();
}
if (defined($options{"A"})) {
    $showall = 1;
}
if (defined($options{"R"})) {
    $raw = 1;
}
if (defined($options{"S"})) {
    if (!exists($sortmap{$options{"S"}})) {
	print STDERR "invalid sort field '$options{S}'\n";
	usage();
    }
    $sortby = $sortmap{$options{"S"}};
}
if (defined($options{"a"})) {
    $showalloconly = 1;
}
if (defined($options{"l"})) {
    $list = 1;
}
if (defined($options{"n"})) {
    $numrecs = $options{"n"};
}
if (defined($options{"x"})) {
    $startrecord = $options{"x"};
}
if (defined($options{"r"})) {
    $revorder = 1;
}
if (defined($options{"s"})) {
    $summary = 1;
}
if (defined($options{"d"})) {
    $datetime = timelocal(strptime($options{"d"}));
    $summary  = 0;
}
if (defined($options{"t"})) {
    if (!defined($datetime)) {
	$datetime  = time() - $options{"t"};
	$datelimit = time();
    }
    else {
	$datelimit = $datetime;
	$datetime  = $datetime - $options{"t"};
    }
}
if (defined($options{"c"})) {
    $showcurrent = 1;
    usage()
	if (!defined($datetime));
}
if (defined($options{"i"})) {
    $ip = $options{"i"};
    $summary  = 0;
}
if (defined($options{"w"})) {
    $warnme = 1;
}
if (defined($options{"v"})) {
    $verbose = 1;
}
if (!$showall && @ARGV == 0 && !defined($ip)) {
    usage();
}
my @nodes = @ARGV;

if (!$list && !$summary) {
    $list = 1;
}

my %nodeinfo;	# [ expt, starttime, uid ]
my @rawrecords;
my %startinfo;

#
# Common case: a single node.
# Just fetch data for it, otherwise fetch data for all.
# 
#
# If we have a datetime, then we want to start with records greater
# then the stamp, but we will not know the state at that point, since
# it will be the most recent record *before* the requested stamp, that
# says what the node is doing at the time. So, this query does some
# amazing magic to find those records without an explosion of terms
# that takes forever. Kudos to Gary for figuring out this query. 
#
if ($datetime) {
    my $querymod = "";
    
    if (@nodes) {
	$querymod = " AND (" .
	            join(" or ", map {"h1.node_id='$_'"} @nodes) . ")";
    }
    elsif (defined($ip)) {
	$querymod = " AND h1.cnet_ip='$ip'";
    }

    my $query_result =
	DBQueryFatal("SELECT h1.node_id,h1.op,h1.stamp,h1.uid,h1.exptidx,".
		     "       s.pid,s.eid,history_id ".
		     "    FROM node_history as h1 ".
		     "JOIN (SELECT h3.node_id,MAX(h3.stamp) as stamp ".
		     "         FROM node_history as h3 ".
		     "      WHERE stamp < $datetime ".
		     "      GROUP BY h3.node_id ".
		     "     ) AS h2 ON h1.node_id=h2.node_id AND ".
		     "                h1.stamp = h2.stamp ".
		     "left join nodes as n on n.node_id=h1.node_id ".
		     "left join node_types as t on t.type=n.type ".
		     "left join experiment_stats as s on s.exptidx=h1.exptidx ".
		     "where t.isplabdslice=0 and t.isplabphysnode=0 and ".
		     "      (n.role='testnode' or n.role='virtnode') ".
		     "$querymod order by h1.node_id");
    
    while (my %row = $query_result->fetchhash()) {
	my $pid = $row{pid};
	my $eid = $row{eid};
	my $pideid = "$pid/$eid";
	my $exptidx = $row{"exptidx"};
	my $node = $row{node_id};
	my $stamp = $row{stamp};
	my $uid = $row{uid};
	my $op = $row{op};
	my $history_id = $row{"history_id"};
	my $cstamp = ctime($stamp);
	my $diff = $datetime - $stamp;
	chomp($cstamp);

	if ($op eq "alloc" || $op eq "move" || $op eq "create") {
	    if ($showcurrent) {
		next
		    if ($pid eq TBOPSPID());

		if ($verbose) {
		    print "$node '$stamp' $diff $uid $pid $eid\n";
		}
		else {
		    print "$node REC $stamp $diff $uid $pid $eid ".
			"$exptidx $history_id\n";
		}
	    }
	    else {
		$nodeinfo{$node} =
		    [ $pideid, $exptidx, $stamp, $uid. $history_id ];
	    }
	}
	elsif ($op eq "free" || $op eq "destroy") {
	    if (!$showcurrent) {
		$nodeinfo{$node} = [ "", undef, $stamp, $uid, $history_id ];
	    }
	}
    }
}
exit(0)
    if ($showcurrent);

my $querymod = "";
if ($startrecord) {
    $querymod = " AND history_id>='$startrecord'";
}
if (@nodes) {
    $querymod .= " AND (" . join(" or ", map {"node_id='$_'"} @nodes) . ")";
}
elsif (defined($ip)) {
    $querymod .= " AND cnet_ip='$ip'";
}

# XXX maybe it would be better to sort them here in perl, outside the DB?
#     Note that the combo field order by is strictly to convince mysql
#     to use an index for sort instead of filesort. I have no idea why
#     it does this, but it cuts the query from 70 seconds to under 1 second.
#
my $orderby = " ORDER BY history_id,stamp ASC";
# Bogus, but reading the entire table is nuts! Millions of rows. 
my $limitby = ($showall && $numrecs ? "limit " . $numrecs * 10 : "");

my $query_result =
    DBQueryFatal("SELECT node_id,stamp,op,uid,pid,eid, ".
		 "  experiment_stats.exptidx,cnet_ip,phys_nodeid,history_id ".
		 "FROM node_history,experiment_stats ".
		 "WHERE node_history.exptidx=experiment_stats.exptidx ".
		 "$querymod " .
		 ($datetime  ? " and stamp>='$datetime'  " : "").
		 ($datelimit ? " and stamp<='$datelimit' " : "").
		 "$orderby $limitby");

while (my %row = $query_result->fetchhash()) {
    my $pideid = "$row{pid}/$row{eid}";
    my $exptidx = $row{"exptidx"};
    my $node = $row{node_id};
    my $stamp = $row{stamp};
    my $uid = $row{uid};
    my $history_id = $row{"history_id"};

    #
    # XXX if this is the first record for a node, consider it as free
    # from the epoch til now.
    #
    if (!defined($nodeinfo{$node})) {
	$nodeinfo{$node} = [ "", undef, $epoch, "root", $history_id ];
    }

    my ($opideid, $oidx, $ostamp, $ouid, $ohistory_id) = @{$nodeinfo{$node}};
    my $elapsed = $stamp - $ostamp;

    #
    # Allocating node to experiment.
    # Should currently be free.
    #
    if ($row{op} eq "alloc") {
	if ($opideid ne "") {
	    print STDERR "$node: dup alloc: already allocated to $opideid\n"
		if ($warnme);
	    # XXX possibly missing state in the DB, treat as move
	}
	$nodeinfo{$node} = [ $pideid, $exptidx, $stamp, $uid, $history_id ];
    }

    #
    # Free or move terminates a node's time in an experiment.
    #
    elsif ($row{op} eq "free") {
	if ($opideid ne $pideid) {
	    print STDERR "$node: mismatched alloc,free records: $opideid,$pideid\n"
		if ($warnme);
	}
	$nodeinfo{$node} = [ "", undef, $stamp, $uid, $history_id ];
    }
    elsif ($row{op} eq "move") {
	if (!$raw) {
	    # Moves from reloadpending to reloading are combined as reloading
	    if ($opideid eq "emulab-ops/reloadpending" &&
		$pideid eq "emulab-ops/reloading") {
		$nodeinfo{$node} = [ $pideid, $exptidx, $ostamp, $ouid,
				     $history_id ];
		next;
	    }
	}
	$nodeinfo{$node} = [ $pideid, $exptidx, $stamp, $uid, $history_id ];
    }
    elsif ($row{op} eq "create") {
	if ($opideid ne "") {
	    print STDERR "$node: dup alloc: already allocated to $opideid\n"
		if ($warnme);
	    # XXX possibly missing state in the DB.
	}
	$nodeinfo{$node} = [ $pideid, $exptidx, $stamp, $uid, $history_id ];
    }
    elsif ($row{op} eq "destroy") {
	if ($opideid ne $pideid) {
	    print STDERR "$node: mismatched create,destroy records: ".
		"$opideid,$pideid\n"
		if ($warnme);
	}
	$nodeinfo{$node} = [ "", undef, $stamp, $uid, $history_id ];
    }
    #print "R: $node, $opideid, $oidx, $ouid, $ostamp, $elapsed\n";
    
    # save off the record
    push(@rawrecords,
	 [ $node, $opideid, $oidx, $ouid, $ostamp, $elapsed, $ohistory_id ]);
}

if (!$datetime) {
    # Include the current state of nodes in a final record
    my $stamp = time();
    for $node (keys(%nodeinfo)) {
	my ($opideid, $oidx, $ostamp, $ouid, $ohistory_id)= @{$nodeinfo{$node}};
	my $elapsed = $stamp - $ostamp;
	push(@rawrecords,
	     [ $node, $opideid, $oidx, $ouid, $ostamp, $elapsed, $ohistory_id]);
    }
}

#
# Loop over the raw records, computing summary stats and creating
# a another set of records to print (if desired).
#
my @records = ();

for my $rec (@rawrecords) {
    my ($node, $pideid, $exptidx, $uid, $stamp, $elapsed, $history_id)= @{$rec};

    #print "RR: $node, $elapsed\n";

    if (!defined($nodestats{$node})) {
	$nodestats{$node} = [ 0, 0, 0, 0 ];
    }
    my ($ftime, $atime, $rtime, $dtime) = @{$nodestats{$node}};
    my $isalloced = 0;
    if ($pideid eq "") {
	$ftime += $elapsed;
    } elsif ($pideid eq "emulab-ops/reloadpending" ||
	     $pideid eq "emulab-ops/reloading") {
	$rtime += $elapsed;
    } elsif ($pideid eq "emulab-ops/hwdown") {
	$dtime += $elapsed;
    } else {
	$atime += $elapsed;
	$isalloced = 1;
    }
    $nodestats{$node} = [ $ftime, $atime, $rtime, $dtime ];

    if ($list) {
	my ($pid, $eid);
	if ($pideid eq "") {
	    $pid = $eid = "<FREE>";
	    $exptidx = 0;
	} else {
	    ($pid, $eid) = split("/", $pideid);
	}
	push(@records,
	     [$node, $stamp, $elapsed, $uid, $pid, $eid, $exptidx,
	      # For sort
	      "$pid/$eid", $history_id])
	    if (!$showalloconly || $isalloced);
    }
}

# Sort the list as desired
if ($sortby ne $sortbydate) {
    @records = sort byfield @records;
}
if ($revorder) {
    @records = reverse(@records);
}

# Prune to the proper number of entries (first/last $numrecs entries)
if ($numrecs && $numrecs < $#records) {
    if ($numrecs > 0) {
	@records = @records[0 .. $numrecs-1];
    } else {
	@records = @records[$numrecs .. -1 ];
    }
}

if (@records) {
    foreach my $record (@records) {
	my ($node, $stamp, $elapsed, $uid, $pid, $eid,
	    $exptidx, undef, $history_id) = @$record;

	if ($verbose) {
	    $stamp = ctime($stamp);
	    chomp($stamp);
	    print "$node '$stamp' $elapsed $uid $pid $eid\n";
	}
	else {
	    print "$node REC $stamp $elapsed $uid $pid $eid ".
		"$exptidx $history_id\n";
	}
    }
}

#
# Print out summary information
#
for $node (sort keys(%nodestats)) {
    if ($summary && defined($nodestats{$node})) {
	my ($ftime, $atime, $rtime, $dtime) = @{$nodestats{$node}};
	my $ttime = $ftime + $atime + $rtime + $dtime;

	if ($verbose) {
	    my $pct;
	    print "$node SUMMARY\n";
	    if ($atime > 0) {
		$pct = ($atime * 100) / $ttime;
		printf("  Allocted:  %9d sec (%5.1f%%)\n", $atime, $pct);
	    }
	    if ($ftime > 0) {
		$pct = ($ftime * 100) / $ttime;
		printf("  Free:      %9d sec (%5.1f%%)\n", $ftime, $pct);
	    }
	    if ($rtime > 0) {
		$pct = ($rtime * 100) / $ttime;
		printf("  Reloading: %9d sec (%5.1f%%)\n", $rtime, $pct);
	    }
	    if ($dtime > 0) {
		$pct = ($dtime * 100) / $ttime;
		printf("  Down:      %9d sec (%5.1f%%)\n", $dtime, $pct);
	    }
	} else {
	    print "$node SUM $atime $ftime $rtime $dtime\n";
	}
    }
}

exit(0);
