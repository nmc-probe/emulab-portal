#!/usr/bin/perl -w
#
# EMULAB-COPYRIGHT
# Copyright (c) 2003-2012 University of Utah and the Flux Group.
# All rights reserved.
#
use strict;
use English;
use Getopt::Std;
use XML::Simple;
use Date::Parse;
use Time::Local;
use Data::Dumper;
use File::Temp qw(tempfile);

#
# Checkin at the master (Utah) to see if we should download and install
# any new images. This is very ProtoGeni specific and should probably
# not be used in other contexts unless you know what you are doing.
#
sub usage()
{
    print STDERR "Usage: getimages [-d] [-n]\n";
    print STDERR "  -h     This message\n";
    print STDERR "  -n     Impotent mode; just check and report.\n";
    exit(-1);
}
my $optlist  = "hndt:";
my $debug    = 1;
my $impotent = 0;
my $testfile;

# Protos
sub fatal($);

#
# Configure variables
#
my $TB		 = "@prefix@";
my $METAURL      = "http://www.emulab.net/genirack-imageinfo.xml";
my $FETCH	 = "/usr/bin/fetch";
my $SUDO         = "/usr/local/bin/sudo";
my $PROTOUSER    = "elabman";
my $WAP          = "$TB/sbin/withadminprivs";
my $metadata	 = "/tmp/imageinfo-$$.xml";
my $NEWIMAGE_EZ  = "$TB/bin/newimageid_ez";

#
# Testbed Support libraries
#
use lib "@prefix@/lib";
use emdb;
use Image;
use OSinfo;
use libaudit;
use EmulabConstants;
use libEmulab;

#
# Turn off line buffering on output
#
$| = 1;

#
# Untaint the path
# 
$ENV{'PATH'} = "/bin:/sbin:/usr/bin:";

#
# When the testbed is shutdown, skip. 
#
if (libEmulab::IsShutDown()) {
    print "Testbed is shutdown; exiting ...\n";
    exit(0);
}

#
# Parse command arguments. Once we return from getopts, all that should be
# left are the required arguments.
#
my %options = ();
if (! getopts($optlist, \%options)) {
    usage();
}
if (defined($options{'h'})) {
    usage();
}
if (defined($options{'n'})) {
    $impotent = 1;
}
if (defined($options{'d'})) {
    $debug = 1;
}
if (defined($options{'t'})) {
    $testfile = $options{'t'};
}
usage()
    if (@ARGV);

# Only root.
if ($UID && !$impotent) {
    die("*** $0:\n".
	"    Must run this as root!\n");
}

# Record output in case of error.
LogStart(0, undef, LIBAUDIT_LOGTBOPS());

#
# Fetch the metadata, which tells what to do.
#
if (!defined($testfile)) {
    print "Fetching metadata from the server\n"
	if ($debug);
    system("$FETCH -o $metadata $METAURL") == 0
	or fatal("Could not fetch $METAURL");
}
else {
    $metadata = $testfile;
}

#
# Must wrap the parser in eval since it exits on error.
#
my $xmlparse = eval { XMLin($metadata,
			    VarAttr => 'name',
			    ForceArray => ['image'],
			    ContentKey => '-content',
			    SuppressEmpty => undef); };
fatal($@)
    if ($@);

#
#
#
foreach my $imageid (keys(%{ $xmlparse->{'image'} })) {
    my $attributes = $xmlparse->{'image'}->{$imageid}->{'attribute'};

    if ($debug) {
	print STDERR Data::Dumper->Dump([$attributes], [$imageid]);
    }

    my $metaurl  = $attributes->{'metaurl'};
    my $imageurl = $attributes->{'imageurl'};
    my $hashurl  = $attributes->{'hashurl'};
    my $newtime  = timegm(strptime($attributes->{'modtime'}));

    #
    # If we have an entry in the DB, we use the modtime as a serial
    # number to determine if we need to go the next step and compare
    # hashes.
    #
    # XXX What if the local site has its own more recent version?
    #     Need to deal with this at some point.
    #
    # Lookup will sanity check the imageid string.
    #
    my $image = Image->Lookup(TBOPSPID(), $imageid);
    if (defined($image)) {
	print "Local descriptor found: $image\n"
	    if ($debug);

	if (defined($image->updated())) {
	    my $updated = timelocal(strptime($image->updated()));

	    if ($updated == $newtime) {
		print "Image has not changed, skipping ...\n"
		    if ($debug);
		next;
	    }
	}
	print "$imageid timestamp has changed. Checking hash.\n";
    }
    else {
	print "$imageid does not exist.\n";
    }

    #
    # Grab the hash file from the server.
    #
    my ($fh, $hashfilename) = tempfile(UNLINK => !$debug);
    fatal("Could not create temporary file")
	if (!defined($fh));
    close($fh);

    print "Fetching $hashurl\n";
    system("$FETCH  -o $hashfilename $hashurl") == 0
	or fatal("Could not fetch $hashurl");

    my $hash = `cat $hashfilename`;
    if ($hash =~ /^SHA1.*= (\w*)$/) {
	$hash = $1;
    }
    else {
	fatal("Could not parse the sha1 hash: '$hash'")
    }

    #
    # If we have the image defined and the hash matches, then done.
    #
    if (defined($image)) {
	if (defined($image->hash()) && $image->hash() eq $hash) {
	    print "Image hash has not changed, skipping ...\n"
		if ($debug);
	    # Update the timestamp to avoid repeat.
	    $image->MarkUpdateTime($newtime);
	    next;
	}
    }

    #
    # Grab the metadata file
    #
    my ($fh2, $metafilename) = tempfile(UNLINK => !$debug);
    fatal("Could not create temporary file")
	if (!defined($fh2));
    close($fh2);

    print "Fetching $metaurl\n";
    system("$FETCH  -o $metafilename $metaurl") == 0
	or fatal("Could not fetch $metaurl");

    #
    # Load up the descriptor if we do not have it.
    #
    if (!defined($image)) {
	# Do this as admin cause of admin only options in the descriptor.
	system("$SUDO -u $PROTOUSER $WAP $NEWIMAGE_EZ -a $metafilename") == 0
	    or fatal("Could not create descriptor for $imageid");
    }
    $image = Image->Lookup(TBOPSPID(), $imageid);
    if (!defined($image)) {
	fatal("Could not lookup newly created descriptor for $imageid");
    }

    my $imagefilename = "$TB/images/${imageid}.ndz";
    my $tmpfilename   = "${imagefilename}.new";
    unlink($tmpfilename)
	if (-e $tmpfilename);
    print "Fetching $imageurl\n";
    system("$FETCH  -o $tmpfilename $imageurl") == 0
	or fatal("Could not fetch $imageurl");

    #
    # Do an integrity check.
    #
    print "Doing an integrity check ...\n";
    my $filehash = `/sbin/sha1 -q $tmpfilename`;
    if ($?) {
	fatal("Could not generate sha1 of $tmpfilename");
    }
    chomp($filehash);
    if ($filehash ne $hash) {
	fatal("Integrity check failure. $hash ne $filehash");
    }

    if ($impotent) {
	print "Impotent mode is on; not installing the new image.\n";
	print "Hash:$hash, time:$newtime\n";
	next;
    }

    #
    # So move it into place.
    #
    print "Moving new image into place\n";
    rename("${imagefilename}", "${imagefilename}.old")
	if (-e "${imagefilename}");
    rename("$tmpfilename", "${imagefilename}") or
	fatal("Could not rename $tmpfilename: $!");

    #
    # Now update the descriptor to reflect new hash.
    #
    $image->SetHash($hash) == 0
	or fatal("Could not update hash for $image");

    #
    # Mark this too, so that we do not repeat the first test above.
    #
    $image->MarkUpdateTime($newtime);
}

exit(0);

sub fatal($)
{
    my ($mesg) = $_[0];

    unlink($metadata)
	if (-e $metadata);
    die("*** $0:\n".
	"    $mesg\n");
}


